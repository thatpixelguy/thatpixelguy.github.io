<!DOCTYPE HTML>
<html>

  <head>
    <title>Linear Algebra: 3D Rasterizer</title>
    <script type="text/javascript" src="math.js"></script>
    <script type="text/javascript" src="graphics.js"></script>

    <style>
      body {
        margin: 0px;
        padding: 0px;
        background-color: #f0f0f0;
        font-family: 'Consolas', 'Menlo', 'Courier New';
      }


      #wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        margin: auto;
        padding: 0;
      }

      #left {
        position: fixed;
        top: 0;
        left: 0;
        width: 50%;
        height: 100%;
        min-width: 500px;
        background-color: #000;

      }

      #right {
        float: right;
        left: 50%;
        width: 50%;
        height: 100%;
        background-color: white;
        min-left: 500px;
      }

      li {
        margin-top: 20px;
      }

    </style>
  </head>

  <body>

  <div id="wrapper">
    <div id="left">
      <center>
        <div style="height: 100%;">
        <canvas id="3d" width="500" height="500"></canvas>
        </div>
      </center>
    </div>
    <div id="right">
      <div style='padding: 30px;'>
        <h1>3D Rasterizer</h1>
        <p>Created by Michael Burns</p>
        <p>This is a simple rasterizer that demonstrates the application of linear algebra to 3D computer graphics.</p>
        <p>Here's a step-by-step summary of what the program does:</p>
        <ol>
          <li>At the start of the program, we define the vertices for a bunch of triangles in 3D space. These form the shape of the 3D object. Then we initiate the rendering loop.</li>
          <li>To render the image (which happens ~60 times per second), we first create 4x4 transformation matrices for each of the 3D objects -- these are used to perform the desired transformations. For example, if we want to rotate a cube and shift it away from the origin, we multiply the identity matrix by rotation and translation matrices -- the result is the cube's transformation matrix.</li>
          <li>Next, we iterate through all of the objects in the scene, and in an inner-loop we iterate through each triangle in each object. To apply the object's transformation matrix, we multiply that matrix by each of the triangle's three vertices. Then we multiply those results by a perspective matrix; the three resulting vectors contain the coordinates of the triangle projected onto our screen.</li>
          <li>Now that we've projected the 3D triangles onto a flat plane, we need to rasterize them. (That is, depict them as pixels on the screen!) Starting at the topmost vertex of the triangle, we iterate through each integer y value of the triangle. Given y<sub>i</sub>, we calculate the x values of the leftmost and rightmost edges of the triangle, then draw a horizontal line of pixels from end to end. (This approach is called scanline rendering.)</li>
          <li>We also keep track of the Z-value of each pixel and only draw over an existing pixel if the new pixel is closer to the screen. (This is called Z-buffering.)</li>
        </ol>

        <h3>Some interesting notes</h3>
        <p>We're using using homogeneous coordinates in this program for a few reasons: First, it's impossible to translate a vector in 3-space by multiplying it with a 3x3 matrix. (Essentially only scaling, rotation, and shearing are possible.) To perform translations, we need to multiply a 4D vector by a 4x4 matrix. To convert our 3D coordinates to 4D, we simply introduce a new coordinate, w, to each vector, and we set it to 1. For example, let's say we want to move the point (0, 2, 3) to the right by 4 units. Observe the following:</p>
        <p><img src='translation.png'>
        </p>
        <p>Homogeneous coordinates are also necessary for perspective projections. The basic idea is that for objects that are very far away, we need to "scale" them down so that they <i>appear</i> to be farther away. We do this by setting the w coordinate to -z and dividing the x, y, and z coordinates by w. (Why do we want w = -z instead of positive z? Because in our orientation, (0, 0, -1) is the forward direction vector of the camera, which means all visible objects will have negative z values.) We also need to account for the camera's field of view and a few other things, so our perspective transformation matrix looks like this:</p>
        <p><img src='perspective.png'><br/><i>f is the distance to the "far" clipping plane of the camera, n is the distance to the "near" plane, and fov is the angle of the camera's field of view.</i></p>

        <p><b>Source files: <a href='graphics.js'>graphics.js</a> | <a href='math.js'>math.js</a></b></p>

      </div>
    </div>
    

    <script type="text/javascript">
      setWorkingCanvas("3d");
      init();
    </script>

  </body>

</html>  